/home/sam/github/fastapi-your-data
├── app
│   ├── api
│   │   └── routes
│   │       ├── documents.py
│   │       ├── __init__.py
│   │       └── users.py
│   ├── core
│   │   ├── middleware.py
│   │   └── security.py
│   ├── database
│   │   ├── init_db.py
│   │   ├── models
│   │   │   ├── documents.py
│   │   │   └── user.py
│   │   └── sqlalchemy_connection.py
│   ├── __init__.py
│   ├── main.py
│   ├── repository
│   │   ├── documents.py
│   │   └── users.py
│   ├── schemas
│   │   ├── documents.py
│   │   └── user.py
│   └── utils
│       ├── hash_password.py
│       └── __init__.py
├── code_report.py
├── config
│   ├── __init__.py
│   └── settings.py
├── custom_tree_and_files_corrected.txt
├── docker-compose.yml
├── Dockerfile
├── .env
├── .env.template
├── .gitignore
├── LICENSE
├── logs
│   ├── esg_spider_2024-01-10_16-46-05_583672.log
│   ├── esg_spider_2024-01-10_16-48-36_849011.log
│   ├── esg_spider_2024-01-10_16-49-37_298579.log
│   ├── esg_spider_2024-01-10_16-53-27_844718.log
│   ├── esg_spider_2024-01-10_16-53-32_386758.log
│   ├── esg_spider_2024-01-10_17-15-14_294201.log
│   ├── esg_spider_2024-01-10_17-16-30_123521.log
│   ├── esg_spider_2024-01-10_17-18-30_501488.log
│   ├── esg_spider_2024-01-10_17-57-30_239909.log
│   ├── esg_spider_2024-01-10_18-09-46_349904.log
│   ├── esg_spider_2024-01-10_18-13-00_406682.log
│   ├── esg_spider_2024-01-10_18-23-06_536955.log
│   ├── esg_spider_2024-01-10_18-34-40_076658.log
│   └── esg_spider_2024-01-10_18-35-44_956037.log
├── README.md
└── requirements.txt

12 directories, 43 files


=== Content of /home/sam/github/fastapi-your-data/Dockerfile ===



=== Content of /home/sam/github/fastapi-your-data/code_report.py ===

Code present but not reported for space reasons

=== Content of /home/sam/github/fastapi-your-data/README.md ===

Questa è una repo in cui è strutturato un template focalizzato a costruire il backend di un applicazione modulare e scalabile utilizzando FastAPI e sqlAlchemy con focus sull'accesso ai dati da parte di vari utenti

Al momento non consideriamo il service layer aggiuntivo ma gestiamo direttamente nei routes

It is feasible to use a repository-service pattern in some complex FastAPI applications through DI. The repository-service pattern is responsible for the creation of the repository layer of the application, which manages the Creation, Reading, Updates, and Deletion (CRUD) of data source. A repository layer requires data models that depict the table schemas of a collection or database. The repository layer needs the service layer to establish a connection with other parts of the application. The service layer operates like a business layer, where the data sources and business processes meet to derive all the necessary objects needed by the REST API. The communication between the repository and service layers can only be possible by creating injectables.

With the power of DI, we have created an online recipe system with an organized set of models, repository, and service layers. The project structure shown in Figure 3.3 is quite different from the previous prototypes because of the additional layers, but it still has main.py and all the packages and modules with their respective APIRouter.

FastAPI allows you to build independent sub-applications inside the main application.

Mounting the submodules
All the FastAPI decorators of each sub-application must be mounted in the main.py component of the top-level application for them to be accessed at runtime. The mount() function is invoked by the FastAPI decorator object of the top-level application, which adds all FastAPI instances of the sub-applications into the gateway application (main.py) and maps each with its corresponding URL context.

Creating a common gateway
It will be easier if we use the URL of the main application to manage the requests and redirect users to any of the three sub-applications. The main application can stand as a pseudo-reverse proxy or an entry point for user requests, which will always redirect user requests to any of the desired sub-applications. This kind of approach is based on a design pattern called API Gateway. Now, let us explore how we can apply this design to manage independent microservices mounted onto the main application using a workaround.

There are so many solutions when it comes to implementing this gateway endpoint, and among them is having a simple REST API service in the top-level application with an integer path parameter that will identify the ID parameter of the microservice.

Managing a microservice’s configuration details
So far, this chapter has provided us with some popular design patterns and strategies that can give us a kickstart on how to provide our FastAPI microservices with the best structures and architecture. This time, let us explore how the FastAPI framework supports storing, assigning, and reading configuration details to mounted microservice applications such as database credentials, networking configuration data, application server information, and deployment details. First, we need to install python-dotenv using pip:

pip install python-dotenv

All of these settings are values that are external to the implementation of the microservice applications. Instead of hardcoding them into the code as variable data, usually, we store them in the env, property, or INI files. However, challenges arise when assigning these settings to different microservices.

Frameworks that support the externalized configuration design pattern have an internal processing feature that fetches environment variables or settings without requiring additional parsing or decoding techniques. For instance, the FastAPI framework has built-in support for externalized settings through pydantic’s BaseSettings class.

Storing settings in the properties file
Another option is to store all these settings inside a physical file with an extension of .env, .properties, or .ini. For instance, this project has the erp_settings.properties file found in the /config folder

Setting up the database connection

To connect to any database, SQLAlchemy requires an engine that manages the connection pooling and the installed dialect. The create_engine() function from the sqlalchemy module is the source of the engine object. But to successfully derive it, create_engine() requires a database URL string to be configured. This URL string contains the database name, the database API driver, the account credentials, the IP address of the database server, and its port.

Initializing the session factory
All CRUD transactions in SQLAlchemy are driven by sessions. Each session manages a group of database "writes" and "reads," and it checks whether to execute them or not. For instance, it maintains a group of inserted, updated, and deleted objects, checks whether the changes are valid, and then coordinates with the SQLAlchemy core to pursue the changes to the database if all transactions have been validated. It follows the behavior of the Unit of Work design pattern. SQLAlchemy relies on sessions for data consistency and integrity.

from sqlalchemy.orm import sessionmaker
engine = create_engine(DB_URL)
SessionFactory = sessionmaker(autocommit=False,
autoflush=False, bind=engine)
Apart from engine binding, we also need to set the session’s autocommit property to False to impose commit() and rollback() transactions. The application should be the one to flush all changes to the database, so we need to set its autoflush feature to False as well.

Applications can create more than one session through the SessionFactory() call, but having one session per APIRouter is recommended.

Defining the Base class
Next, we need to set up the Base class, which is crucial in mapping model classes to database tables. Although SQLAlchemy can create tables at runtime, we opted to utilize an existing schema definition for our prototype. Now, this Base class must be subclassed by the model classes so that the mapping to the tables will happen once the server starts. The following script shows how straightforward it is to set up this component:

from sqlalchemy.ext.declarative import declarative_base
Base = declarative_base()
Invoking the declarative_base() function is the easiest way of creating the Base class rather than creating registry() to call generate_base(), which can also provide us with the Base class.

Note that all these configurations are part of the /db_config/sqlalchemy_connect.py module of the prototype. They are bundled into one module since they are crucial in building the SQLAlchemy repository. But before we implement the CRUD transactions, we need to create the model layer using the Base class.

Implementing the repository layer
In the SQLAlchemy ORM, creating the repository layer requires the model classes and a Session object. The Session object, derived from the SessionFactory()directive, establishes all the communication to the database and manages all the model objects before the commit() or rollback() transaction. When it comes to the queries, the Session entity stores the result set of records in a data structure called an identity map, which maintains the unique identity of each data record using the primary keys.

All repository transactions are stateless, which means the session is automatically closed after loading the model objects for insert, update, and delete transactions when the database issues a commit() or rollback() operation. We import the Session class from the sqlalchemy.orm module.

---

lancia con il comando

uvicorn app.main:app --reload


=== Content of /home/sam/github/fastapi-your-data/config/settings.py ===

from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    environment: str = "development"

    sqlalchemy_database_url_dev: str
    sqlalchemy_database_url_prod: str

    @property
    def sqlalchemy_database_url(self) -> str:
        return (
            self.sqlalchemy_database_url_dev
            if self.environment == "development"
            else self.sqlalchemy_database_url_prod
        )

    class Config:
        env_file = ".env"


settings = Settings()


=== Content of /home/sam/github/fastapi-your-data/app/main.py ===

from fastapi import FastAPI
from fastapi.responses import RedirectResponse
from loguru import logger

from app.api.routes.documents import docs_router
from app.api.routes.users import user_router

from fastapi import FastAPI, Request
from loguru import logger
from uuid import uuid4
import sys
from fastapi.responses import JSONResponse
import uvicorn


app = FastAPI()

app.include_router(docs_router, prefix="/documents")
app.include_router(user_router, prefix="/user")


@app.get("/metrics")
def metrics():
    return {"message": "This is a dummy metrics endpoint."}


@app.get("/")
async def home():
    return RedirectResponse(url="/docs")


logger.remove()
logger.add(
    sys.stdout,
    level="INFO",
    format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {message}",
)
logger.add(
    "logs/esg_spider_{time}.log",
    rotation="1 day",
    retention="7 days",
    level="INFO",
    format="{time:YYYY-MM-DD HH:mm:ss} | {level} | {message}",
)


@app.middleware("http")
async def log_middleware(request: Request, call_next):
    log_id = str(uuid4())
    with logger.contextualize(log_id=log_id):
        logger.info("Request to access " + request.url.path)
        try:
            response = await call_next(request)
        except Exception as ex:
            logger.error(f"Request to " + request.url.path + " failed: {ex}")
            response = JSONResponse(content={"success": False}, status_code=500)
        finally:
            logger.info("Successfully accessed " + request.url.path)
            return response


if __name__ == "__main__":
    uvicorn.run("app_main:app", host="0.0.0.0", port=8080, reload=True)


=== Content of /home/sam/github/fastapi-your-data/app/utils/hash_password.py ===

from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")


class HashPassword:
    def create_hash(self, password: str):
        return pwd_context.hash(password)

    def verify_hash(self, plain_password: str, hashed_password: str):
        return pwd_context.verify(plain_password, hashed_password)


=== Content of /home/sam/github/fastapi-your-data/app/schemas/user.py ===

from pydantic import BaseModel, EmailStr


class UserCreate(BaseModel):
    email: EmailStr
    password: str


class UserResponse(BaseModel):
    email: EmailStr
    token: str


=== Content of /home/sam/github/fastapi-your-data/app/schemas/documents.py ===

from pydantic import BaseModel
from datetime import datetime
from typing import Optional


class DocumentsResponse(BaseModel):
    id: int
    url: str
    status: str
    notes: Optional[str]
    download_path: str
    downloaded_at: datetime
    keywords_namefile: str


=== Content of /home/sam/github/fastapi-your-data/app/core/middleware.py ===



=== Content of /home/sam/github/fastapi-your-data/app/core/security.py ===



=== Content of /home/sam/github/fastapi-your-data/app/database/init_db.py ===

# init_db.py
from app.database.sqlalchemy_connection import engine, Base
from app.database.models.user import User
from app.database.models.documents import Documents
from loguru import logger


def init_db():
    # Create all tables
    Base.metadata.create_all(bind=engine)
    logger.info("All tables created")


if __name__ == "__main__":
    init_db()


=== Content of /home/sam/github/fastapi-your-data/app/database/sqlalchemy_connection.py ===

from sqlalchemy import create_engine
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker
from contextlib import contextmanager
from config.settings import settings

# Define the base class for your models
Base = declarative_base()

# Create the SQLAlchemy engine
engine = create_engine(settings.sqlalchemy_database_url, echo=False)

# Create a configured "SessionFactory" class
SessionFactory = sessionmaker(autocommit=False, autoflush=False, bind=engine)


=== Content of /home/sam/github/fastapi-your-data/app/database/models/user.py ===

from sqlalchemy import Column, Integer, String
from app.database.sqlalchemy_connection import Base
import uuid


class User(Base):
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True)
    password = Column(String)
    token = Column(String, default=lambda: str(uuid.uuid4()))


=== Content of /home/sam/github/fastapi-your-data/app/database/models/documents.py ===

from sqlalchemy import Column, Integer, String, DateTime
from app.database.sqlalchemy_connection import Base
from datetime import datetime


class Documents(Base):
    __tablename__ = "documents"

    id = Column(Integer, primary_key=True, index=True)
    url = Column(String, unique=True)
    status = Column(String)
    notes = Column(String)
    download_path = Column(String)
    downloaded_at = Column(DateTime, default=datetime.utcnow)
    keywords_namefile = Column(String)


=== Content of /home/sam/github/fastapi-your-data/app/repository/users.py ===

from fastapi import HTTPException, status
from sqlalchemy.orm import Session
from app.database.models.user import User
from app.utils.hash_password import HashPassword
from loguru import logger
from uuid import uuid4
from sqlalchemy import select


class UsersRepository:
    def __init__(self, sess: Session):
        self.sess: Session = sess
        self.hash_password = HashPassword()

    def generate_token(self):
        # Generate a unique token for the user, you might want to use JWT or other methods
        return str(uuid4())

    def add_user(self, user_data):
        hashed_password = self.hash_password.create_hash(user_data.password)
        token = self.generate_token()
        new_user = User(email=user_data.email, password=hashed_password, token=token)

        try:
            self.sess.add(new_user)
            self.sess.commit()
            self.sess.refresh(new_user)
            return new_user
        except Exception as e:
            logger.error(f"Error adding new user: {e}")
            self.sess.rollback()
            raise

    def get_user_by_email(self, email):
        try:
            existing_user = self.sess.execute(
                select(User).where(User.email == email)
            ).scalar()

            return existing_user
        except Exception as e:
            logger.error(f"Error fetching user by email: {e}")
            raise


=== Content of /home/sam/github/fastapi-your-data/app/repository/documents.py ===

from sqlalchemy.orm import Session
from app.database.models.documents import Documents
from loguru import logger


class DocumentsRepository:
    def __init__(self, db: Session):
        self.db = db

    def get_all_documents(self):
        try:
            documents = self.db.query(Documents).all()
            return documents
        except Exception as e:
            logger.error(f"Error fetching documents: {e}")
            raise


=== Content of /home/sam/github/fastapi-your-data/app/api/routes/users.py ===

from fastapi import APIRouter, HTTPException, Depends, status
from sqlalchemy.orm import Session
from app.database.sqlalchemy_connection import SessionFactory
from app.repository.users import UsersRepository
from app.schemas.user import UserCreate, UserResponse
from loguru import logger


def sess_db():
    db = SessionFactory()
    try:
        yield db
    finally:
        db.close()


user_router = APIRouter(tags=["User"])


@user_router.post("/signup", response_model=UserResponse)
async def sign_up_user(user_data: UserCreate, sess: Session = Depends(sess_db)):
    users_repo = UsersRepository(sess)
    logger.info("Creating new user")
    try:
        # Check if user already exists
        if users_repo.get_user_by_email(user_data.email):
            raise HTTPException(
                status_code=status.HTTP_409_CONFLICT,
                detail="User with supplied email already exists",
            )
        # Create new user
        new_user = users_repo.add_user(user_data)
        return UserResponse(email=new_user.email, token=new_user.token)
    except Exception as e:
        logger.error(f"Failed to sign up user: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail="Internal Server Error")


@user_router.post("/signin", response_model=UserResponse)
async def sign_in_user(email: str, password: str, sess: Session = Depends(sess_db)):
    users_repo = UsersRepository(sess)
    # Verify email
    user = users_repo.get_user_by_email(email)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND, detail="User not found"
        )
    # Verify password
    if not users_repo.hash_password.verify_hash(password, user.password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect password"
        )
    return UserResponse(email=user.email, token=user.token)


=== Content of /home/sam/github/fastapi-your-data/app/api/routes/documents.py ===

from fastapi import APIRouter, Depends
from sqlalchemy.orm import Session
from app.database.sqlalchemy_connection import SessionFactory
from app.repository.documents import DocumentsRepository
from app.schemas.documents import DocumentsResponse
from typing import List
from loguru import logger


def sess_db():
    db = SessionFactory()
    try:
        yield db
    finally:
        db.close()


docs_router = APIRouter()


@docs_router.get("/", response_model=List[DocumentsResponse])
async def retrieve_all_documents(sess: Session = Depends(sess_db)):
    documents_repo = DocumentsRepository(sess)
    documents = documents_repo.get_all_documents()
    logger.info(f"Retrieved {len(documents)} documents")
    return documents
